Imprimir a ordem em que os nós são visitados com DFS:


// Exemplo de pesquisa em profundidade (DFS) num grafo nao dirigido

import java.util.*;
import java.io.*;

public class DFS {
    static int n; // Numero de nos do grafo
    static boolean adj[][]; // Matriz de adjacencias
    static boolean visited[]; // Que nos ja foram visitados?

    static void dfs(int v) {
        System.out.print(v + " ");
        visited[v] = true;
        for (int i = 1; i <= n; i++)
            if (adj[v][i] && !visited[i])
                dfs(i);
    }

    public static void main(String args[]) {
        Scanner stdin = new Scanner(System.in);

        n = stdin.nextInt();
        adj = new boolean[n + 1][n + 1];
        visited = new boolean[n + 1];
        int edges = stdin.nextInt();
        for (int i = 0; i < edges; i++) {
            int a = stdin.nextInt();
            int b = stdin.nextInt();
            adj[a][b] = adj[b][a] = true;
        }

        dfs(1); // Pesquisa em profundidade a partir do no 1
        System.out.println();
    }
}



Problema com DFS I - contando componentes conexas

Calcular quantidade e/ou tamanho/peso de componentes conexos:


// Java program for above approach
import java.io.*;
import java.util.*;

public class ConnectedComponentCount {

    private int v;
    private int e;
    private Map<Integer, HashSet<Integer>> adjMap;
    private static Map<Integer, Integer> visited;

    ConnectedComponentCount(int vertices) {
        v = vertices;
        adjMap = new HashMap<Integer, HashSet<Integer>>();
        visited = new HashMap<Integer, Integer>();
    }

    // Function to add edges
    private void addEdge(int s, int d) {
        adjMap.putIfAbsent(s, new HashSet<Integer>());
        adjMap.putIfAbsent(d, new HashSet<Integer>());
        adjMap.get(s).add(d);
        adjMap.get(s).add(s);
        adjMap.get(d).add(s);
        adjMap.get(d).add(d);
        visited.put(s, 0);
        visited.put(d, 0);
    }

    // To mark vertices which can be visites
    private void findDFS(int vertex) {

        // Mark as visited
        visited.put(vertex, 1);

        // Print the vertex
        //System.out.println("vertex " + vertex + " visited");
        for (Integer child : adjMap.get(vertex)) {
            if (visited.get(child) == 0) {
                findDFS(child);
            }
        }
    }

    // Function to print graph
    private void printGraph() {
        for (HashSet<Integer> v : adjMap.values()) {
            //System.out.println(v.toString());
        }
    }

    // Driver Code
    public static void main(String args[])
	{
		
		Scanner stdin = new Scanner(System.in);
		//System.out.println("Enter the number of vertices (V): ");
		int vertices = stdin.nextInt();
		
		//System.out.println("Enter the number of edges (E): ");
		int edges = stdin.nextInt();
		
		// To count total number of
		// components
		int numeroComponentes = 0;
		
		ConnectedComponentCount ccc = new ConnectedComponentCount(vertices);
		
		// Input of edges
		while (edges > 0)
		{
			//System.out.println("Enter the nodes s & d: ");
			int s = stdin.nextInt();
			int d = stdin.nextInt();
			ccc.addEdge(s,d);
			edges-- ;
		}
		
		// Function to print graph					 
		ccc.printGraph();
		
		// Traversing every node 
		for(Integer vertex : visited.keySet())
		{
			
			// Check if vertex is already
			// visited or not
			if(visited.get(vertex) == 0)
			{
				
				// Function Call for findDFS
				ccc.findDFS(vertex);
			
				// Print Component Found
				//System.out.println("CC Found");
			
				// Increase the counter
				numeroComponentes++;
			}
		}
		
		// Print number of components					 
		System.out.println("Number of cc component: " + numeroComponentes);
	}
}


Ver o maior comprimento de arestas:

// Java program to find 
// unique count of 
// connected components
import java.util.*;
import java.util.List;
import java.util.ArrayList;

class GFG {

    // Function to add edge in the garph
    static void add_edge(int u, int v, Vector<Integer> graph[]) {
        graph[u].add(v);
        graph[v].add(u);
    }

    // Function to traverse the undirected graph
    // using DFS algorithm and keep a track of
    // individual lengths of connected chains
    static int depthFirst(int v, Vector<Integer> graph[], Vector<Boolean> visited, int ans) {
        // Marking the visited vertex as true
        visited.add(v, true);
        //System.out.print(v + " ");

        // Incrementing the count of
        // connected chain length
        ans++;

        for (int i : graph[v]) {
            if (visited.get(i) == false) {
                // Recursive call to the DFS algorithm
                ans = depthFirst(i, graph, visited, ans);
            }
        }
        return ans;
    }

    // Function to initialize the graph
    // and display the result
    static void UniqueConnectedComponent(int n, Vector<Integer> graph[]) {
        // Initializing boolean visited array
        // to mark visited vertices
        Vector<Boolean> visited = new Vector<>();
        for (int i = 0; i < n + 1; i++)
            visited.add(false);

        // Initializing a Set container
        HashSet<Integer> result = new HashSet<>();

        // Following loop invokes DFS algorithm
        for (int i = 1; i <= n; i++) {
            if (visited.get(i) == false) {
                // ans variable stores the
                // individual counts
                int ans = 0;

                // DFS algorithm
                ans = depthFirst(i, graph, visited, ans);

                // Inserting the counts of connected
                // components in set
                result.add(ans);
                //System.out.print("Count = " + ans + "\n");
            }
        }
        //System.out.print("Unique Counts of " + "connected components: ");

        // The size of the Set container
        // gives the desired result
        System.out.print(result.size() + "\n");
    }

    // Driver code
    public static void main(String[] args) {

       
        Scanner stdin = new Scanner(System.in);

        int n = stdin.nextInt();
        int edges = stdin.nextInt();

        // Create graph
        Vector<Integer>[] graph = new Vector[n + 1];
        for (int i = 0; i < graph.length; i++)
            graph[i] = new Vector<Integer>();

        // Constructing the undirected graph

        for (int i = 0; i < edges; i++){
            int a = stdin.nextInt();
            int b = stdin.nextInt();
            add_edge(a, b, graph);
        }

        // Function call
        UniqueConnectedComponent(n, graph);
    }
}





Saber verificar se um grafo é bipartido:




// Java program to check if a connected 
// graph is bipartite or not suing DFS 
import java.util.*;

class Bipartite {

    // Function to store the connected nodes
    static void addEdge(ArrayList<ArrayList<Integer>> adj, int u, int v) {
        adj.get(u).add(v);
        adj.get(v).add(u);
    }

    // Function to check whether a
    // graph is bipartite or not
    static boolean isBipartite(ArrayList<ArrayList<Integer>> adj, int v, boolean visited[], int color[]) {
        for (int u : adj.get(v)) {

            // If vertex u is not explored before
            if (visited[u] == false) {

                // Mark present vertic as visited
                visited[u] = true;

                // Mark its color opposite to its parent
                color[u] = 1 - color[v];

                // If the subtree rooted at vertex
                // v is not bipartite
                if (!isBipartite(adj, u, visited, color))
                    return false;
            }

            // If two adjacent are colored with
            // same color then the graph is
            // not bipartite
            else if (color[u] == color[v])
                return false;
        }
        return true;
    }

    // Driver Code
    public static void main(String args[]) {

        // No of nodes
        Scanner stdin = new Scanner(System.in);

        int n = stdin.nextInt();

        // To maintain the adjacency list of graph
        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>(n + 1);

        // Initialize all the vertex
        for (int i = 0; i <= n; i++) {
            adj.add(new ArrayList<Integer>());
        }

        // To keep a check on whether
        // a node is discovered or not
        boolean visited[] = new boolean[n + 1];

        // To color the vertices
        // of graph with 2 color
        int color[] = new int[n + 1];

        // The value '-1' of colorArr[i] is
        // used to indicate that no color is
        // assigned to vertex 'i'. The value
        // 1 is used to indicate first color
        // is assigned and value 0 indicates
        // second color is assigned.
        Arrays.fill(color, -1);

        // Adding edges to the graph
        int edges = stdin.nextInt();

        for (int i = 0; i < edges; i++) {
            int a = stdin.nextInt();
            int b = stdin.nextInt();
            addEdge(adj, a, b);
        }

        // Marking the source node as visited
        visited[1] = true;

        // Marking the source node with a color
        color[1] = 0;

        // Function to check if the graph
        // is Bipartite or not
        if (isBipartite(adj, 1, visited, color)) {
            System.out.println("Graph is Bipartite");
        } else {
            System.out.println("Graph is not Bipartite");
        }
    }
}



Saber calcular uma ordenação topológica:



// A Java program to print topological 
// sorting of a DAG 
import java.io.*;
import java.util.*;

// This class represents a directed graph 
// using adjacency list representation 
class Graph {
    // No. of vertices
    private int V;

    // Adjacency List as ArrayList of ArrayList's
    private ArrayList<ArrayList<Integer>> adj;

    // Constructor
    Graph(int v) {
        V = v;
        adj = new ArrayList<ArrayList<Integer>>(v);
        for (int i = 0; i < v; ++i)
            adj.add(new ArrayList<Integer>());
    }

    // Function to add an edge into the graph
    void addEdge(int v, int w) {
        adj.get(v).add(w);
    }

    // A recursive function used by topologicalSort
    void topologicalSortUtil(int v, boolean visited[], Stack<Integer> stack) {
        // Mark the current node as visited.
        visited[v] = true;
        Integer i;

        // Recur for all the vertices adjacent
        // to thisvertex
        Iterator<Integer> it = adj.get(v).iterator();
        while (it.hasNext()) {
            i = it.next();
            if (!visited[i])
                topologicalSortUtil(i, visited, stack);
        }

        // Push current vertex to stack
        // which stores result
        stack.push(new Integer(v));
    }

    // The function to do Topological Sort.
    // It uses recursive topologicalSortUtil()
    void topologicalSort() {
        Stack<Integer> stack = new Stack<Integer>();

        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;

        // Call the recursive helper
        // function to store
        // Topological Sort starting
        // from all vertices one by one
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                topologicalSortUtil(i, visited, stack);

        // Print contents of stack
        while (stack.empty() == false)
            System.out.print(stack.pop() + " ");
    }

    // Driver code
    public static void main(String args[]) {
        // Create a graph given in the above diagram
        Graph g = new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);

        System.out.println("Following is a Topological " + "sort of the given graph");
        // Function Call
        g.topologicalSort();
    }
}



Saber usar pesquisa em largura (BFS) para calcular distâncias num grafo não pesado

        Implementar um grafo pesado:

        
import java.util.LinkedList;

public class WeightedGraph {
    static class Edge {
        int source;
        int destination;
        int weight;

        public Edge(int source, int destination, int weight) {
            this.source = source;
            this.destination = destination;
            this.weight = weight;
        }
    }

    static class Graph {
        int vertices;
        LinkedList<Edge>[] adjacencylist;

        Graph(int vertices) {
            this.vertices = vertices;
            adjacencylist = new LinkedList[vertices];
            // initialize adjacency lists for all the vertices
            for (int i = 0; i < vertices; i++) {
                adjacencylist[i] = new LinkedList<>();
            }
        }

        public void addEgde(int source, int destination, int weight) {
            Edge edge = new Edge(source, destination, weight);
            adjacencylist[source].addFirst(edge); // for directed graph
        }

        public void printGraph() {
            for (int i = 0; i < vertices; i++) {
                LinkedList<Edge> list = adjacencylist[i];
                for (int j = 0; j < list.size(); j++) {
                    System.out.println("vertex-" + i + " is connected to " + list.get(j).destination + " with weight "
                            + list.get(j).weight);
                }
            }
        }
    }

    public static void main(String[] args) {
        int vertices = 6;
        Graph graph = new Graph(vertices);
        graph.addEgde(0, 1, 4);
        graph.addEgde(0, 2, 3);
        graph.addEgde(1, 3, 2);
        graph.addEgde(1, 2, 5);
        graph.addEgde(2, 3, 7);
        graph.addEgde(3, 4, 2);
        graph.addEgde(4, 0, 4);
        graph.addEgde(4, 1, 4);
        graph.addEgde(4, 5, 6);
        graph.printGraph();
    }
}



        Diâmetro ou raio de um grafo:

    The diameter of graph is the maximum distance between the pair of vertices. It can also be defined as the maximal 
    distance between the pair of vertices. Way to solve it is to find all the paths and then find the maximum of all.


    A radius of the graph exists only if it has the diameter. The minimum among all the maximum distances between a 
    vertex to all other vertices is considered as the radius of the Graph G.It is denoted as r(G).




BFS :


// Java program to print BFS traversal from a given source vertex.
// BFS(int s) traverses vertices reachable from s.
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency list
// representation
class Graph {
    private int V; // No. of vertices
    private LinkedList<Integer> adj[]; // Adjacency Lists

    // Constructor
    Graph(int v) {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v, int w) {
        adj[v].add(w);
    }

    // prints BFS traversal from a given source s
    void BFS(int s) {
        // Mark all the vertices as not visited(By default
        // set as false)
        boolean visited[] = new boolean[V];

        // Create a queue for BFS
        LinkedList<Integer> queue = new LinkedList<Integer>();

        // Mark the current node as visited and enqueue it
        visited[s] = true;
        queue.add(s);

        while (queue.size() != 0) {
            // Dequeue a vertex from queue and print it
            s = queue.poll();
            System.out.print(s + " ");

            // Get all adjacent vertices of the dequeued vertex s
            // If a adjacent has not been visited, then mark it
            // visited and enqueue it
            Iterator<Integer> i = adj[s].listIterator();
            while (i.hasNext()) {
                int n = i.next();
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    // Driver method to
    public static void main(String args[]) {
        Graph g = new Graph(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Breadth First Traversal " + "(starting from vertex 2)");

        g.BFS(2);
    }
}


Diskstra


// Java implementation of Dijkstra's Algorithm 
// using Priority Queue 
import java.util.*;

public class DPQ {
    private int dist[];
    private Set<Integer> settled;
    private PriorityQueue<Node> pq;
    private int V; // Number of vertices
    List<List<Node>> adj;

    public DPQ(int V) {
        this.V = V;
        dist = new int[V];
        settled = new HashSet<Integer>();
        pq = new PriorityQueue<Node>(V, new Node());
    }

    // Function for Dijkstra's Algorithm
    public void dijkstra(List<List<Node>> adj, int src) {
        this.adj = adj;

        for (int i = 0; i < V; i++)
            dist[i] = Integer.MAX_VALUE;

        // Add source node to the priority queue
        pq.add(new Node(src, 0));

        // Distance to the source is 0
        dist[src] = 0;
        while (settled.size() != V) {

            // remove the minimum distance node
            // from the priority queue
            int u = pq.remove().node;

            // adding the node whose distance is
            // finalized
            settled.add(u);

            e_Neighbours(u);
        }
    }

    // Function to process all the neighbours
    // of the passed node
    private void e_Neighbours(int u) {
        int edgeDistance = -1;
        int newDistance = -1;

        // All the neighbors of v
        for (int i = 0; i < adj.get(u).size(); i++) {
            Node v = adj.get(u).get(i);

            // If current node hasn't already been processed
            if (!settled.contains(v.node)) {
                edgeDistance = v.cost;
                newDistance = dist[u] + edgeDistance;

                // If new distance is cheaper in cost
                if (newDistance < dist[v.node])
                    dist[v.node] = newDistance;

                // Add the current node to the queue
                pq.add(new Node(v.node, dist[v.node]));
            }
        }
    }

    // Driver code
    public static void main(String arg[]) {
        int V = 5;
        int source = 0;

        // Adjacency list representation of the
        // connected edges
        List<List<Node>> adj = new ArrayList<List<Node>>();

        // Initialize list for every node
        for (int i = 0; i < V; i++) {
            List<Node> item = new ArrayList<Node>();
            adj.add(item);
        }

        // Inputs for the DPQ graph
        adj.get(0).add(new Node(1, 9));
        adj.get(0).add(new Node(2, 6));
        adj.get(0).add(new Node(3, 5));
        adj.get(0).add(new Node(4, 3));

        adj.get(2).add(new Node(1, 2));
        adj.get(2).add(new Node(3, 4));

        // Calculate the single source shortest path
        DPQ dpq = new DPQ(V);
        dpq.dijkstra(adj, source);

        // Print the shortest path to all the nodes
        // from the source node
        System.out.println("The shorted path from node :");
        for (int i = 0; i < dpq.dist.length; i++)
            System.out.println(source + " to " + i + " is " + dpq.dist[i]);
    }
}

// Class to represent a node in the graph
class Node implements Comparator<Node> {
    public int node;
    public int cost;

    public Node() {
    }

    public Node(int node, int cost) {
        this.node = node;
        this.cost = cost;
    }

    @Override
    public int compare(Node node1, Node node2) {
        if (node1.cost < node2.cost)
            return -1;
        if (node1.cost > node2.cost)
            return 1;
        return 0;
    }
}













Shortest Path


// Java to shortest path from a given source vertex 's' to 
// a given destination vertex 't'. Expected time complexity 
// is O(V+E). 
import java.util.*;

class GFG {

    // This class represents a directed graph using adjacency
    // list representation
    static class Graph {
        int V; // No. of vertices
        Vector<Integer>[] adj; // No. of vertices

        static int level;

        // Constructor
        @SuppressWarnings("unchecked")
        Graph(int V) {
            this.V = V;
            this.adj = new Vector[2 * V];

            for (int i = 0; i < 2 * V; i++)
                this.adj[i] = new Vector<>();
        }

        // adds an edge
        public void addEdge(int v, int w, int weight) {

            // split all edges of weight 2 into two
            // edges of weight 1 each. The intermediate
            // vertex number is maximum vertex number + 1,
            // that is V.
            if (weight == 2) {
                adj[v].add(v + this.V);
                adj[v + this.V].add(w);
            } else // Weight is 1
                adj[v].add(w); // Add w to v's list.
        }

        // print shortest path from a source vertex 's' to
        // destination vertex 'd'.
        public int printShortestPath(int[] parent, int s, int d) {
            level = 0;

            // If we reached root of shortest path tree
            if (parent[s] == -1) {
                System.out.printf("Shortest Path between" + "%d and %d is %s ", s, d, s);
                return level;
            }

            printShortestPath(parent, parent[s], d);

            level++;
            if (s < this.V)
                System.out.printf("%d ", s);

            return level;
        }

        // finds shortest path from source vertex 's' to
        // destination vertex 'd'.

        // This function mainly does BFS and prints the
        // shortest path from src to dest. It is assumed
        // that weight of every edge is 1
        public int findShortestPath(int src, int dest) {
            boolean[] visited = new boolean[2 * this.V];
            int[] parent = new int[2 * this.V];

            // Initialize parent[] and visited[]
            for (int i = 0; i < 2 * this.V; i++) {
                visited[i] = false;
                parent[i] = -1;
            }

            // Create a queue for BFS
            Queue<Integer> queue = new LinkedList<>();

            // Mark the current node as visited and enqueue it
            visited[src] = true;
            queue.add(src);

            while (!queue.isEmpty()) {

                // Dequeue a vertex from queue and print it
                int s = queue.peek();

                if (s == dest)
                    return printShortestPath(parent, s, dest);
                queue.poll();

                // Get all adjacent vertices of the dequeued vertex s
                // If a adjacent has not been visited, then mark it
                // visited and enqueue it
                for (int i : this.adj[s]) {
                    if (!visited[i]) {
                        visited[i] = true;
                        queue.add(i);
                        parent[i] = s;
                    }
                }
            }
            return 0;
        }
    }

    // Driver Code
    public static void main(String[] args) {

        // Create a graph given in the above diagram
        int V = 4;
        Graph g = new Graph(V);
        g.addEdge(0, 1, 2);
        g.addEdge(0, 2, 2);
        g.addEdge(1, 2, 1);
        g.addEdge(1, 3, 1);
        g.addEdge(2, 0, 1);
        g.addEdge(2, 3, 2);
        g.addEdge(3, 3, 2);

        int src = 0, dest = 3;
        System.out.printf("\nShortest Distance between" + " %d and %d is %d\n", src, dest,
                g.findShortestPath(src, dest));
    }
}





Print all nodes at distance k from a given node


// Java program to print all nodes at a distance k from given node 

// A binary tree node 
class Node {
    int data;
    Node left, right;

    Node(int item) {
        data = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;
    /*
     * Recursive function to print all the nodes at distance k in tree (or subtree)
     * rooted with given root.
     */

    void printkdistanceNodeDown(Node node, int k) {
        // Base Case
        if (node == null || k < 0)
            return;

        // If we reach a k distant node, print it
        if (k == 0) {
            System.out.print(node.data);
            System.out.println("");
            return;
        }

        // Recur for left and right subtrees
        printkdistanceNodeDown(node.left, k - 1);
        printkdistanceNodeDown(node.right, k - 1);
    }

    // Prints all nodes at distance k from a given target node.
    // The k distant nodes may be upward or downward.This function
    // Returns distance of root from target node, it returns -1
    // if target node is not present in tree rooted with root.
    int printkdistanceNode(Node node, Node target, int k) {
        // Base Case 1: If tree is empty, return -1
        if (node == null)
            return -1;

        // If target is same as root. Use the downward function
        // to print all nodes at distance k in subtree rooted with
        // target or root
        if (node == target) {
            printkdistanceNodeDown(node, k);
            return 0;
        }

        // Recur for left subtree
        int dl = printkdistanceNode(node.left, target, k);

        // Check if target node was found in left subtree
        if (dl != -1) {

            // If root is at distance k from target, print root
            // Note that dl is Distance of root's left child from
            // target
            if (dl + 1 == k) {
                System.out.print(node.data);
                System.out.println("");
            }

            // Else go to right subtree and print all k-dl-2 distant nodes
            // Note that the right child is 2 edges away from left child
            else
                printkdistanceNodeDown(node.right, k - dl - 2);

            // Add 1 to the distance and return value for parent calls
            return 1 + dl;
        }

        // MIRROR OF ABOVE CODE FOR RIGHT SUBTREE
        // Note that we reach here only when node was not found in left
        // subtree
        int dr = printkdistanceNode(node.right, target, k);
        if (dr != -1) {
            if (dr + 1 == k) {
                System.out.print(node.data);
                System.out.println("");
            } else
                printkdistanceNodeDown(node.left, k - dr - 2);
            return 1 + dr;
        }

        // If target was neither present in left nor in right subtree
        return -1;
    }

    // Driver program to test the above functions
    public static void main(String args[]) {
        BinaryTree tree = new BinaryTree();

        /* Let us construct the tree shown in above diagram */
        tree.root = new Node(20);
        tree.root.left = new Node(8);
        tree.root.right = new Node(22);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(12);
        tree.root.left.right.left = new Node(10);
        tree.root.left.right.right = new Node(14);
        Node target = tree.root.left.right;
        tree.printkdistanceNode(tree.root, target, 2);
    }
}




Implementing Adjacency Matrices


Now that we've seen how adjacency matrices work on paper, we need to consider their implementation. 
If our "nodes" were indeed simply integer values 0,1,...n-1, the implementation would be fairly straightforward.

However, since this often isn't the case, we need to figure out how we can use the convenience of 
using matrix indices as nodes when our nodes are objects.

In our implementation we'll be making our class as versatile as possible. This is reflected in a 
few more methods and some edge-cases being taken into consideration.

We'll also provide the choice between a directed and undirected graph, as well as a 
weighted/unweighted one.


public class Graph {

    private int numOfNodes;
    private boolean directed;
    private boolean weighted;
    private float[][] matrix;

    /*
     This will allow us to safely add weighted graphs in our class since
     we will be able to check whether an edge exists without relying
     on specific special values (like 0)
    */
    private boolean[][] isSetMatrix;

    // ...
}

Then, we'll have a simple constructor:

public Graph(int numOfNodes, boolean directed, boolean weighted) {

    this.directed = directed;
    this.weighted = weighted;
    this.numOfNodes = numOfNodes;

    // Simply initializes our adjacency matrix to the appropriate size
    matrix = new float[numOfNodes][numOfNodes];
    isSetMatrix = new boolean[numOfNodes][numOfNodes];
}


Now, let's write a method that allows us to add edges. We want to make sure 
that in case the graph is weighted and a weight isn't provided we set the 
edge value to 0, and if isn't weighted to simply add 1:

/*
 Since matrices for directed graphs are symmetrical, we have to add
 [destination][source] at the same time as [source][destination]
*/
public void addEdge(int source, int destination) {

    int valueToAdd = 1;

    if (weighted) {
        valueToAdd = 0;
    }

    matrix[source][destination] = valueToAdd;
    isSetMatrix[source][destination] = true;

    if (!directed) {
        matrix[destination][source] = valueToAdd;
        isSetMatrix[destination][source] = true;
    }
}


In case the graph isn't weighted and a weight is provided, we simply ignore that and set 
the [source,destination] value to 1, indicating that an edge does exist:

public void addEdge(int source, int destination, float weight) {

    float valueToAdd = weight;

    if (!weighted) {
        valueToAdd = 1;
    }

    matrix[source][destination] = valueToAdd;
    isSetMatrix[source][destination] = true;

    if (!directed) {
        matrix[destination][source] = valueToAdd;
        isSetMatrix[destination][source] = true;
    }
}


At this point, let's add a method that allows us to easily print out the adjacency matrix:

public void printMatrix() {
    for (int i = 0; i < numOfNodes; i++) {
        for (int j = 0; j < numOfNodes; j++) {
            // We only want to print the values of those positions that have been marked as set
            if (isSetMatrix[i][j])
                System.out.format("%8s", String.valueOf(matrix[i][j]));
            else System.out.format("%8s", "/  ");
        }
        System.out.println();
    }
}


And after that, a convenience method that prints out the edges in a more understandable way:

/*
 We look at each row, one by one.
 When we're at row i, every column j that has a set value represents that an edge exists from
 i to j, so we print it
*/
public void printEdges() {
    for (int i = 0; i < numOfNodes; i++) {
        System.out.print("Node " + i + " is connected to: ");
        for (int j = 0; j < numOfNodes; j++) {
            if (isSetMatrix[i][j]) {
                System.out.print(j + " ");
            }
        }
        System.out.println();
    }
}


Finally, let's write two helper methods that'll be used later on:

public boolean hasEdge(int source, int destination) {
    return isSetMatrix[source][destination];
}

public Float getEdgeValue(int source, int destination) {
    if (!weighted || !isSetMatrix[source][destination])
        return null;
    return matrix[source][destination];
}
To showcase how an adjacency matrix works, let's use our class to make a graph, populate it with relations, and print them:

public class GraphShow {
    public static void main(String[] args) {

        // Graph(numOfNodes, directed, weighted)
        Graph graph = new Graph(5, false, true);

        graph.addEdge(0, 2, 19);
        graph.addEdge(0, 3, -2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(1, 3); // The default weight is 0 if weighted == true
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printMatrix();

        System.out.println();
        System.out.println();

        graph.printEdges();

        System.out.println();
        System.out.println("Does an edge from 1 to 0 exist?");
        if (graph.hasEdge(0,1)) {
            System.out.println("Yes");
        }
        else System.out.println("No");
    }
}
Which gives us the output:

     /       /      19.0    -2.0     /
     /       /       3.0     0.0     0.0
    19.0     3.0     /       0.0     /
    -2.0     0.0     0.0     /       0.0
     /       0.0     /       0.0     /


Node 0 is connected to: 2 3
Node 1 is connected to: 2 3 4
Node 2 is connected to: 0 1 3
Node 3 is connected to: 0 1 2 4
Node 4 is connected to: 1 3

Does an edge from 1 to 0 exist?
No
null



Implementing Adjacency Lists


The code might seem complex at first glance but it's rather straight-forward when you look closely. First, let's start off with a simple Node class:

public class Node {
    int n;
    String name;

    Node(int n, String name){
        this.n = n;
        this.name = name;
    }
}
Now, let's define a Graph:

public class Graph {

// Each node maps to a list of all his neighbors
private HashMap<Node, LinkedList<Node>> adjacencyMap;
private boolean directed;

public Graph(boolean directed) {
    this.directed = directed;
    adjacencyMap = new HashMap<>();
}
Now, let's add the method addEdge(). Although this time around we'll use two methods, a helper method and the actual method.

In the helper method, we'll also make a check for possible duplicate edges. Before adding an edge between A and B, we'll first remove it and only then add it. If it existed (we're adding a duplicate edge), it was removed and after adding it again, there's only one.

Though, if it didn't exist, removing a non-existing edge will result in a NullPointerException so we're introducing a temporary copy of the list:

public void addEdgeHelper(Node a, Node b) {
    LinkedList<Node> tmp = adjacencyMap.get(a);

    if (tmp != null) {
        tmp.remove(b);
    }
    else tmp = new LinkedList<>();
    tmp.add(b);
    adjacencyMap.put(a,tmp);
}

public void addEdge(Node source, Node destination) {

    // We make sure that every used node shows up in our .keySet()
    if (!adjacencyMap.keySet().contains(source))
        adjacencyMap.put(source, null);

    if (!adjacencyMap.keySet().contains(destination))
        adjacencyMap.put(destination, null);

    addEdgeHelper(source, destination);

    // If a graph is undirected, we want to add an edge from destination to source as well
    if (!directed) {
        addEdgeHelper(destination, source);
    }
}
Finally, we'll have the printEdges() and hasEdge() helper methods, which are pretty straightforward:

public void printEdges() {
        for (Node node : adjacencyMap.keySet()) {
            System.out.print("The " + node.name + " has an edge towards: ");
            if (adjacencyMap.get(node) != null) {
                for (Node neighbor : adjacencyMap.get(node)) {
                    System.out.print(neighbor.name + " ");
                }
                System.out.println();
            }
            else {
                System.out.println("none");
            }
        }
    }

    public boolean hasEdge(Node source, Node destination) {
        return adjacencyMap.containsKey(source) && adjacencyMap.get(source) != null && adjacencyMap.get(source).contains(destination);
    }
To showcase how adjacency lists work, let's instantiate several nodes and populate a graph with them:

public class GraphShow {
    public static void main(String[] args) {

        Graph graph = new Graph(true);
        Node a = new Node(0, "A");
        Node b = new Node(1, "B");
        Node c = new Node(2, "C");
        Node d = new Node(3, "D");
        Node e = new Node(4, "E");

        graph.addEdge(a,b);
        graph.addEdge(b,c);
        graph.addEdge(b,d);
        graph.addEdge(c,e);
        graph.addEdge(b,a);

        graph.printEdges();

        System.out.println(graph.hasEdge(a,b));
        System.out.println(graph.hasEdge(d,a));
    }
}
We get the output:

The A has an edge towards: B
The B has an edge towards: C D A
The C has an edge towards: E
true
false
Note: This of course heavily depends on how Java treats objects in memory. We have to make sure that further changes to our a node in main, after we have added it to our graph, will reflect on our graph! Sometimes this is what we aim for, but sometimes it isn't. Either way, we should be aware that in this case, the a node in our graph is the same as the a node in main.

We could have implemented this differently of course. Another popular approach is to add the list of outgoing edges to the Node object itself and change the Graph class appropriately:

public class Node {
    int n;
    String name;
    LinkedList<Node> adjacentNodes;

    Node(int n, String name) {
        this.n = n;
        this.name = name;
        adjacentNodes = new LinkedList<>();
    }

    public void addEdge(Node node) {
        if (!adjacentNodes.contains(node))
            adjacentNodes.add(node);
    }
}
Both approaches are in the spirit of the Object-Oriented encapsulation concept in their own way, so either is fine.




DFS

Implementation
Since we know how to represent graphs in code through adjacency lists and matrices, let's make a graph and traverse it using DFS. The graphs we'll be working with are simple enough that it doesn't matter which implementation we opt for.

Though, for actual projects, in most cases, adjacency lists will be a better choice, so we're going to represent the graph as an adjacency list.

We want to visit all our nodes once, as seen in the animation above they turn red once visited, so we don't visit them anymore. To do this in code, we'll introduce a visited flag:

public class Node {
    int n;
    String name;
    boolean visited; // New attribute

    Node(int n, String name) {
        this.n = n;
        this.name = name;
        visited = false;
    }

    // Two new methods we'll need in our traversal algorithms
    void visit() {
        visited = true;
    }

    void unvisit() {
        visited = false;
    }
}
Now, let's define a Graph:

public class Graph {

    // Each node maps to a list of all his neighbors
    private HashMap<Node, LinkedList<Node>> adjacencyMap;
    private boolean directed;

    public Graph(boolean directed) {
        this.directed = directed;
        adjacencyMap = new HashMap<>();
    }

    // ...
}
Now, let's add the method addEdge(). We'll use two methods, a helper method and the actual method.

In the helper method, we'll also make a check for possible duplicate edges. Before adding an edge between A and B, we'll first remove it and only then add it. If the edge already existed then this prevents us from adding a duplicate edge. If there was not already an edge there then we still only have one edge between the two nodes.

If the edge didn't exist, removing a non-existing edge will result in a NullPointerException so we're introducing a temporary copy of the list:

public void addEdgeHelper(Node a, Node b) {
    LinkedList<Node> tmp = adjacencyMap.get(a);

    if (tmp != null) {
        tmp.remove(b);
    }
    else tmp = new LinkedList<>();
    tmp.add(b);
    adjacencyMap.put(a, tmp);
}

public void addEdge(Node source, Node destination) {

    // We make sure that every used node shows up in our .keySet()
    if (!adjacencyMap.keySet().contains(source))
        adjacencyMap.put(source, null);

    if (!adjacencyMap.keySet().contains(destination))
        adjacencyMap.put(destination, null);

    addEdgeHelper(source, destination);

    // If a graph is undirected, we want to add an edge from destination to source as well
    if (!directed) {
        addEdgeHelper(destination, source);
    }
}
Finally, we'll have the printEdges(), hasEdge() and resetNodesVisited() helper methods, which are pretty straightforward:

public void printEdges() {
    for (Node node : adjacencyMap.keySet()) {
        System.out.print("The " + node.name + " has an edge towards: ");
        for (Node neighbor : adjacencyMap.get(node)) {
            System.out.print(neighbor.name + " ");
        }
        System.out.println();
    }
}

public boolean hasEdge(Node source, Node destination) {
    return adjacencyMap.containsKey(source) && adjacencyMap.get(source).contains(destination);
}

public void resetNodesVisited(){
    for(Node node : adjacencyMap.keySet()){
        node.unvisit();
    }
}
We will also add the depthFirstSearch(Node node) method to our Graph class that does the following:

If the node.visited == true, simply return
If it hasn't been already visited, do the following:
Find the first unvisited neighbor newNode of node and call depthFirstSearch(newNode)
Repeat the process for all unvisited neighbors
Let's illustrate this with an example:

Node A is connected with node D
Node B is connected with nodes D, C
Node C is connected with nodes A, B
Node D is connected with nodes B
All the nodes are unvisited at the beginning (node.visited == false)
Call .depthFirstSeach() with an arbitrary node as the starting node, let's say depthFirstSearch(B)
mark B as visited
Does B have any unvisited neighbors? Yes -> the first unvisited node is D, so call depthFirstSearch(D)
mark D as visited
Does D have any unvisited neighbors? No -> (B has already been visited) return
Does B have any unvisited neighbors? Yes -> the first unvisited node is C, so call depthFirstSearch(C)
mark C as visited
Does C have any unvisited neighbors? Yes -> the first unvisited node is A, so call depthFirstSearch(A)
mark A as visited
Does A have any unvisited neighbors? No. -> return
Does C have any unvisited neighbors? No -> return
Does B have any unvisited neighbors? No -> return
Calling DFS on our graph would give us the traversal B,D,C,A (the order of visitation). When the algorithm is written out like this, it's easy to translate it to code:

public void depthFirstSearch(Node node) {
    node.visit();
    System.out.print(node.name + " ");

    LinkedList<Node> allNeighbors = adjacencyMap.get(node);
    if (allNeighbors == null)
        return;

    for (Node neighbor : allNeighbors) {
        if (!neighbor.isVisited())
            depthFirstSearch(neighbor);
    }
}


DFS is sometimes called an "aggressive" graph traversal because it goes as far as it possibly can through one "branch". As we can see in the gif above, when DFS encounters node 25, it forces the 25 - 12 - 6 - 4 branch until it can't go any further. Only then does the algorithm go back to check for other unvisited neighbors of the previous nodes, starting with the ones more recently visited.

Note: We might have an unconnected graph. An unconnected graph is a graph that doesn't have a path between any two nodes.


In this example, nodes 0, 1, and 2 would be visited and the output would show these nodes, and completely ignore nodes 3 and 4.

A similar thing would happen if we had called depthFirstSearch(4), only this time 4 and 3 would be visited while 0, 1, and 2 wouldn't. The solution to this problem is to keep calling DFS as long as there are any unvisited nodes.

This can be done in several ways, but we can make another slight modification to our Graph class to handle this problem. We'll add a new depthFirstSearchModified(Node node) method:

public void depthFirstSearchModified(Node node) {
    depthFirstSearch(node);

    for (Node n : adjacencyMap.keySet()) {
        if (!n.isVisited()) {
            depthFirstSearch(n);
        }
    }
}

public void depthFirstSearch(Node node) {
    node.visit();
    System.out.print(node.name + " ");

    LinkedList<Node> allNeighbors = adjacencyMap.get(node);
        if (allNeighbors == null)
            return;

    for (Node neighbor : allNeighbors) {
        if (!neighbor.isVisited())
            depthFirstSearch(neighbor);
    }
}
public class GraphShow {
    public static void main(String[] args) {

        Graph graph = new Graph(false);
        Node a = new Node(0, "0");
        Node b = new Node(1, "1");
        Node c = new Node(2, "2");
        Node d = new Node(3, "3");
        Node e = new Node(4, "4");


        graph.addEdge(a,b);
        graph.addEdge(a,c);
        graph.addEdge(c,b);
        graph.addEdge(e,d);

        System.out.println("If we were to use our previous DFS method, we would get an incomplete traversal");
        graph.depthFirstSearch(b);
        graph.resetNodesVisited(); // All nodes are marked as visited because of
                                   // the previous DFS algorithm so we need to
                                   // mark them all as not visited

        System.out.println();
        System.out.println("Using the modified method visits all nodes of the graph, even if it's unconnected");
        graph.depthFirstSearchModified(b);
    }
}
Which gives us the output:

If we were to use our previous DFS method, we would get an incomplete traversal
1 0 2
Using the modified method visits all nodes of the graph, even if it's unconnected
1 0 2 4 3



public class GraphShow {
    public static void main(String[] args) {

        Graph graph = new Graph(true);
        Node zero = new Node(0, "0");
        Node one = new Node(1, "1");
        Node two = new Node(2, "2");
        Node three = new Node(3, "3");
        Node four = new Node(4, "4");
        Node five = new Node(5, "5");
        Node six = new Node(6, "6");
        Node seven = new Node(7, "7");
        Node eight = new Node(8, "8");

        graph.addEdge(one,zero);
        graph.addEdge(three,one);
        graph.addEdge(two,seven);
        graph.addEdge(two,four);
        graph.addEdge(five,two);
        graph.addEdge(five,zero);
        graph.addEdge(six,five);
        graph.addEdge(six,three);
        graph.addEdge(six,eight);
        graph.addEdge(seven,five);
        graph.addEdge(seven,six);
        graph.addEdge(seven,eight);

        graph.depthFirstSearch(seven);
    }
}
This gives us the output:

7 5 2 4 0 6 3 1 8





Ordering Neighbors


Another "fun" thing we might want to add is some order in which neighbors are listed for each node. We can achieve this by using a heap data structure (PriorityQueue in Java) instead of a LinkedList for neighbors and implement a compareTo() method in our Node class so Java knows how to sort our objects:

public class Node implements Comparable<Node> {

    // Same code as before...

    public int compareTo(Node node) {
        return this.n - node.n;
    }
}
class Graph {
    // Replace all occurrences of LinkedList with PriorityQueue
}
public class GraphShow {
    public static void main(String[] args) {

        GraphAdjacencyList graph = new GraphAdjacencyList(true);
        Node a = new Node(0, "0");
        Node b = new Node(1, "1");
        Node c = new Node(2, "2");
        Node d = new Node(3, "3");
        Node e = new Node(4, "4");

        graph.addEdge(a,e);
        graph.addEdge(a,d);
        graph.addEdge(a,b);
        graph.addEdge(a,c);

        System.out.println("When using a PriorityQueue, it doesn't matter in which order we add neighbors, they will always be sorted");
        graph.printEdges();
        System.out.println();

        graph.depthFirstSearchModified(a);
        graph.resetNodesVisited();
    }
}
When using a PriorityQueue, it doesn't matter in which order we add neighbors, they will always be sorted
The 0 has an edge towards: 1 2 3 4

0 1 2 3 4
If we did not use a PriorityQueue, the DFS output would have been 0,4,3,1,2.




BFS



Breadth-First Search
Breadth First Search (BFS) visits "layer-by-layer". This means that in a Graph, like shown below, it first visits all the children of the starting node. These children are treated as the "second layer".

Unlike Depth-First Search (DFS), BFS doesn't aggressively go though one branch until it reaches the end, rather when we start the search from a node, it visits all the unvisited neighbors of that node before proceeding to all the unvisited neighbors of another node:



Implementation
We'll use graphs implemented via an adjacency list, like we used for DFS. Also, we need to add the visited attribute alongside the visit() and univisit() methods to our Node class:

public class Node {
    int n;
    String name;
    boolean visited;

    Node(int n, String name) {
        this.n = n;
        this.name = name;
        visited = false;
    }

    void visit() {
        visited = true;
    }

    void unvisit() {
        visited = false;
    }
}
Now, let's define a Graph:

public class Graph {

    // Each node maps to a list of all his neighbors
    private HashMap<Node, LinkedList<Node>> adjacencyMap;
    private boolean directed;

    public Graph(boolean directed) {
        this.directed = directed;
        adjacencyMap = new HashMap<>();
    }

    // ...
}
Now, let's add the method addEdge(). We'll use two methods, a helper method and the actual method.

In the helper method, we'll also make a check for possible duplicate edges. Before adding an edge between A and B, we'll first remove it and only then add it. If it existed (we're adding a duplicate edge), it was removed and after adding it again, there's only one.

Though, if it didn't exist, removing a non-existing edge will result in a NullPointerException so we're introducing a temporary copy of the list:

public void addEdgeHelper(Node a, Node b) {
    LinkedList<Node> tmp = adjacencyMap.get(a);

    if (tmp != null) {
        tmp.remove(b);
    }
    else tmp = new LinkedList<>();
    tmp.add(b);
    adjacencyMap.put(a,tmp);
}

public void addEdge(Node source, Node destination) {

    // We make sure that every used node shows up in our .keySet()
    if (!adjacencyMap.keySet().contains(source))
        adjacencyMap.put(source, null);

    if (!adjacencyMap.keySet().contains(destination))
        adjacencyMap.put(destination, null);

    addEdgeHelper(source, destination);

    // If a graph is undirected, we want to add an edge from destination to source as well
    if (!directed) {
        addEdgeHelper(destination, source);
    }
}
Finally, we'll have the printEdges(), hasEdge() and resetNodesVisited() helper methods, which are pretty straightforward:

public void printEdges() {
    for (Node node : adjacencyMap.keySet()) {
        System.out.print("The " + node.name + " has an edge towards: ");
        for (Node neighbor : adjacencyMap.get(node)) {
            System.out.print(neighbor.name + " ");
        }
        System.out.println();
    }
}

public boolean hasEdge(Node source, Node destination) {
    return adjacencyMap.containsKey(source) && adjacencyMap.get(source).contains(destination);
}

public void resetNodesVisited(){
    for(Node node : adjacencyMap.keySet()){
        node.unvisit();
    }
}
Let's examine the BFS algorithm on the following undirected graph:

Node 0 has neighbors: 1, 3, 2
Node 1 has neighbors: 0
Node 2 has neighbors: 3, 0
Node 3 has neighbors: 2, 0
We can pick any node to start from, so let's start with 1. We repeat the process of adding and removing nodes from the queue until the queue is empty.

A Queue is a FIFO (first-in-first-out) data structure. It works just like a real-life queue, and so entries are processed (removed from the queue) one by one in the order in which they were added.

This is a very convenient data structure for BFS since we want to process nodes in the order in which we visit them, making sure that we process nodes "closer" to the starting node first.

Since they are added to the queue before any nodes "further" away from the starting node are added to the queue, we know the closer ones will be processed first.


We start off by having a queue that contains only node 1
Remove the first element from the queue, in this case 1, mark it as visited
Add all 1's unvisited neighbors to the queue (only 0)
Remove the first element from the queue, in this case 0, mark it as visited
Add all 0's unvisited neighbors to the queue (nodes 3 and 2, 1 has been marked as visited already)
Remove the first element from the queue, in this case 3, mark it as visited
Add all 3's unvisited neighbors to the queue (there are none)
Remove the first element from the queue, in this case 2, mark it as visited
Add all 2's unvisited neighbors to the queue (again, there are none)
The queue is now empty, BFS has finished



Our nodes are visited in the 1-0-3-2 order. It should be obvious that set of steps 2-3, 4-5, 6-7, and 8-9 are the same and that step 10 is our loop termination condition. Viewed in this way, it should be easy to write code for our breadthFirstSearch(Node node) method.

There are several types of Queue implementations in Java, but we'll use a LinkedList instead, since it provides all the necessary methods.

We're adding the following method to our Graph class:

void breadthFirstSearch(Node node) {

    // Just so we handle receiving an uninitialized Node, otherwise an
    // exception will be thrown when we try to add it to queue
    if (node == null)
        return;

    // Creating the queue, and adding the first node (step 1)
    LinkedList<Node> queue = new LinkedList<>();
    queue.add(node);

    while (!queue.isEmpty()) {
        Node currentFirst = queue.removeFirst();

        // In some cases we might have added a particular node more than once before
        // actually visiting that node, so we make sure to check and skip that node if we have
        // encountered it before
        if (currentFirst.isVisited())
            continue;

        // Mark the node as visited
        currentFirst.visit();
        System.out.print(currentFirst.name + " ");

        LinkedList<Node> allNeighbors = adjacencyMap.get(currentFirst);

        // We have to check whether the list of neighbors is null before proceeding, otherwise
        // the for-each loop will throw an exception
        if (allNeighbors == null)
            continue;

        for (Node neighbor : allNeighbors) {
            // We only add unvisited neighbors
            if (!neighbor.isVisited()) {
                queue.add(neighbor);
            }
        }
    }
    System.out.println();
}
Now we create our example graph in code and check whether our method works as expected:

public class GraphShow {
    public static void main(String[] args) {

        Graph graph = new Graph(false);
        Node a = new Node(0, "0");
        Node b = new Node(1, "1");
        Node c = new Node(2, "2");
        Node d = new Node(3, "3");
        Node e = new Node(4, "4");

        graph.addEdge(a,d);
        graph.addEdge(a,b);
        graph.addEdge(a,c);
        graph.addEdge(c,d);

        graph.breadthFirstSearch(b);
    }
}
Output:

1 0 3 2
If you read the DFS article then you may recall that we encountered a situation where in an unconnected graph, not all of the nodes would be printed out since the algorithm would go through all the nodes it can, and then stop.

The same thing happens with BFS, and this can also happen when graphs are directed, sometimes we can't reach all the nodes. Sometimes this is the behavior we're looking for, but sometimes we want all of the nodes to be visited.

We'll do the same thing as we did in DFS, i.e. we'll keep calling BFS as long as there are any unvisited nodes. We'll make a new breadthFirstSearchModified(Node node) method that does this for us:

void breadthFirstSearchModified(Node node) {
    breadthFirstSearch(node);

    for (Node n : adjacencyMap.keySet()) {
        if (!n.isVisited()) {
            breadthFirstSearch(n);
        }
    }
}
public class GraphShow {
    public static void main(String[] args) {

        Graph graph = new Graph(false);
        Node a = new Node(0, "0");
        Node b = new Node(1, "1");
        Node c = new Node(2, "2");
        Node d = new Node(3, "3");
        Node e = new Node(4, "4");

        graph.addEdge(a,d);
        graph.addEdge(a,b);
        graph.addEdge(c,e);

        System.out.println("Using the unmodified version of BFS we get:");
        graph.breadthFirstSearch(a);

        graph.resetNodesVisited();
        System.out.println("Using the modified version of BFS we get:");
        graph.breadthFirstSearchModified(a);
    }
}
Output:

Using the unmodified version of BFS we get:
0 3 1
Using the modified version of BFS we get:
0 3 1
4 2
There is also something called a "bidirectional" BFS search. This is useful when we want to find the shortest path between two vertices (nodes).

This is achieved by simultaneously (in different threads) running a BFS from the starting node and the destination node. This, in theory, finds the shortest path between two nodes twice as fast as running BFS just from the starting node.

Note: Same as with DFS, if we want to go through the neighbors in a particular order (instead of the order in which the edges were added), we can use a PriorityQueue instead of a LinkedList for the list of neighbors.

The code is the same, we just have to implement Comparable and add a compareTo() method to our Node class.













How does Dijkstra's Algorithm Work?
Dijkstra's algorithm finds the least expensive path in a weighted graph between our starting node and a destination node, if such a path exists.

At the end of the algorithm, when we have arrived at the destination node, we can print the lowest cost path by backtracking from the destination node to the starting node. Later on in the article we'll see how we can do that by keeping track of how we had arrived to each node.

Since we'll be using weighted graphs this time around, we'll have to make a new GraphWeighted class that has the methods necessary for handling them.

Dijkstra's algorithm works like this:

We have a weighted graph G with a set of vertices (nodes) V and a set of edges E
We also have a starting node called s, and we set the distance between s and s to 0
Mark the distance between s and every other node as infinite, i.e. start the algorithm as if no node was reachable from node s
Mark all nodes (other than s) as unvisited, or mark s as visited if all other nodes are already marked as unvisited (which is the approach we'll use)
As long as there is an unvisited node, do the following:
Find the node n that has the shortest distance from the starting node s
Mark n as visited
For every edge between n and m, where m is unvisited:
If cheapestPath(s,n) + cheapestPath(n,m) < cheapestPath(s,m), update the cheapest path between s and m to equal cheapestPath(s,n) + cheapestPath(n,m)
This might seem complicated but let's go through an example that makes this a bit more intuitive:

We're looking for the path with the least weight from node 0 to node 6. We will use a matrix/table to better represent what's going on in the algorithm.

At the beginning, all the data we have is the distance between 0 and its neighboring nodes.

The rest of the distances are denoted as positive infinity, i.e. they are not reachable from any of the nodes we've processed so far (we've only processed 0).

The next step is to find the closest node that hasn't been visited yet that we can actually reach from one of the nodes we've processed. In our case, this is node 1.

Now we'll update the shortest path values if it's necessary. For example, node 3 is now reachable from node 1.

We'll also mark 1 as visited.

Note: We have to take into account how much it "costs" to get to node 1. Since our starting position is 0 and it costs 8 units to get from 0 to 1, we have to add that 8 to the total cost from "moving" from 1 to another node. This is why we add 8 (distance from 0 to 1) + 3 (distance from 1 to 3) = 11 to our table, instead of just 3.

We see that from node 1 we can reach nodes 2, 3, and 4.

Node 2 -> to get from 1 to 2 costs 7 units, given that the shortest path from 0 to 1 costs 8 units, 8 + 7 is greater than 11 (the shortest path between 0 and 2). This means we haven't found a better path from 0 to 2 through the node 1, so we don't change anything.
Node 3 -> to get from 1 to 3 costs 3 units, and since 3 was previously unreachable, 8 + 3 is definitely better than positive infinity, so we update the table in that cell
Node 4 -> same as with node 3, previously unreachable so we update the table for node 4 as well


The dark orange shading helps us keep track of nodes we have visited, we'll discuss why the lighter orange shade was added later.

We can now choose between node 2 and node 3, since both are as "close" to node 0. Let's go with node 3.

Unvisited, reachable nodes from node 3 are nodes 4 and 5:

Node 4 -> it costs 5 units to get from node 3 to node 4, and 11 + 5 isn't better than the previous 16 unit value we found, so there's no need to update
Node 5 -> it costs 2 units to get from node 3 to node 5, and 11 + 2 is better than positive infinity, so we update the table
We mark 3 as visited.


The next node to consider is node 2, however the only node reachable from node 2 is node 4 and the value we get (11 + 9 = 20) isn't better than the previous value we found (16), so we make no changes to our table, other than mark node 2 as visited.


The next closest reachable node is 5, and 5's unvisited neighbors are 4 and 6.

Node 4 -> 13 + 1 is better than 16, so the value is updated
Node 6 -> 13 + 8 is better than positive infinity, so the value is updated
Mark 5 as visited.


Even though we can reach the end node, that's not the closest reachable node (4 is), so we need to visit 4 to check whether it has a better path to node 6.

It turns out that it does. 6 is the only unvisited node reachable from node 4, and 14 + 6 is less than 21. So we update our table one last time.




Since the next closest, reachable, unvisited node is our end node - the algorithm is over and we have our result - the value of the shortest path between 0 and 6 is 20.

This, however, doesn't give us the answer to "WHAT is the cheapest path" between 0 and 6, it only tells us its value. This is where the light orange shading comes in.

We need to figure out how we got to 6, and we do this by checking "when did the value of the shortest path to 6 change the last time?".

Looking at our table, we can see that the value changed from 21 to 20 when we were looking at node 4. We can either see that by looking at the row name that we were in when the value became 20, or the light orange cell's column name right before the value changed.

Now we know that we've arrived at node 6 from node 4, but how did we get to node 4? Following the same principle - we see that 4's value changed for the last time when we were looking at node 5.

Applying the same principle to node 5 -> we arrived from node 3; we arrived at node 3 from node 1, and to node 1 from our starting node, node 0.

This gives us the path 0 -> 1 -> 3 -> 5 -> 4 -> 6 as the path with the least value from 0 to 6. This path sometimes isn't unique, there can be several paths that have the same value.

If you wish to practice the algorithm on another graph before we go into the code, here's another example and the solution - try to find the solution on your own first. We'll be looking for the shortest path between 8 and 6:


Note: Dijkstra's algorithm doesn't work on every type of graph. You might have noticed that we haven't used any negative weights on our edges in our examples - this is because of the simple reason that Dijkstra doesn't work on graphs with any negative weights.

If we ran the algorithm, looking for the least expensive path between 0 and 1, the algorithm would return 0 -> 2 -> 1 even though that's not correct (the least expensive is 0 -> 3 -> 1).




Dijkstra's algorithm sees that the next closest node is 1 so it doesn't check the rest of the unvisited nodes. This just goes to show that Dijkstra doesn't work with graphs that contain negative edges.

Now on to the interesting part - the actual code. There are several ways to design classes for this algorithm, but we've chosen to keep the list of EdgeWeighted objects in the NodeWeighted class, so we have easy access to all the edges from a particular node.

Also, every EdgeWeighted object contains the source NodeWeighted object and the destination NodeWeighted object, just in case we want to try and implement the algorithm differently in the future.

Note: Our implementation relies on objects equality in the true sense, and all our methods share the exact same NodeWeighted object, so any change to that object reflects on the entire graph. This might not be something you want in your code, however relying on this makes our code much more readable and better for educational purposes, so we've chosen that approach.











Implementing a Weighted Graph
Let's start off with the simplest class of all we'll use, the EdgeWeighted class:

public class EdgeWeighted implements Comparable<EdgeWeighted> {

    NodeWeighted source;
    NodeWeighted destination;
    double weight;

    EdgeWeighted(NodeWeighted s, NodeWeighted d, double w) {
        // Note that we are choosing to use the (exact) same objects in the Edge class
        // and in the GraphShow and GraphWeighted classes on purpose - this MIGHT NOT
        // be something you want to do in your own code, but for sake of readability
        // we've decided to go with this option
        source = s;
        destination = d;
        weight = w;
    }

    // ...
}
The NodeWeighted objects represent the actual nodes in our weighted graph. We'll implement that class shortly after the edges.

Now, let's simply implement the toString() method for the sake of printing objects and the compareTo() method:

public String toString() {
    return String.format("(%s -> %s, %f)", source.name, destination.name, weight);
}

// We need this method if we want to use PriorityQueues instead of LinkedLists
// to store our edges, the benefits are discussed later, we'll be using LinkedLists
// to make things as simple as possible
public int compareTo(EdgeWeighted otherEdge) {

    // We can't simply use return (int)(this.weight - otherEdge.weight) because
    // this sometimes gives false results
    if (this.weight > otherEdge.weight) {
        return 1;
    }
    else return -1;
}
With our weighted edges out of the way, let's implement our weighted nodes:

public class NodeWeighted {
    // The int n and String name are just arbitrary attributes
    // we've chosen for our nodes these attributes can of course
    // be whatever you need
    int n;
    String name;
    private boolean visited;
    LinkedList<EdgeWeighted> edges;

    NodeWeighted(int n, String name) {
        this.n = n;
        this.name = name;
        visited = false;
        edges = new LinkedList<>();
    }

    boolean isVisited() {
        return visited;
    }

    void visit() {
        visited = true;
    }

    void unvisit() {
        visited = false;
    }
}
The NodeWeighted is a pretty straightforward class resembling regular nodes we've used before. This time around, the Graph class isn't the one holding the information about the edges between the nodes, but rather, each node contains a list of its own neighbors.

Finally, let's implement the GraphWeighted class which will utilize both of the previous classes to represent a graph:


public class GraphWeighted {
    private Set<NodeWeighted> nodes;
    private boolean directed;

    GraphWeighted(boolean directed) {
        this.directed = directed;
        nodes = new HashSet<>();
    }

    // ...
}
To store our nodes in the graph, we'll be using a Set. They're convenient for us since they don't allow duplicate objects and are generally simple to work with.

Now, as usual, let's define the main methods we'll use to build our graph, starting off with the addNode() method:

// Doesn't need to be called for any node that has an edge to another node
// since addEdge makes sure that both nodes are in the nodes Set
public void addNode(NodeWeighted... n) {
    // We're using a var arg method so we don't have to call
    // addNode repeatedly
    nodes.addAll(Arrays.asList(n));
}
And with it, the addEdge() method alongside the addEdgeHelper() method used for convenience and readability:

public void addEdge(NodeWeighted source, NodeWeighted destination, double weight) {
    // Since we're using a Set, it will only add the nodes
    // if they don't already exist in our graph
    nodes.add(source);
    nodes.add(destination);

    // We're using addEdgeHelper to make sure we don't have duplicate edges
    addEdgeHelper(source, destination, weight);

    if (!directed && source != destination) {
        addEdgeHelper(destination, source, weight);
    }
}

private void addEdgeHelper(NodeWeighted a, NodeWeighted b, double weight) {
    // Go through all the edges and see whether that edge has
    // already been added
    for (EdgeWeighted edge : a.edges) {
        if (edge.source == a && edge.destination == b) {
            // Update the value in case it's a different one now
            edge.weight = weight;
            return;
        }
    }
    // If it hasn't been added already (we haven't returned
    // from the for loop), add the edge
    a.edges.add(new EdgeWeighted(a, b, weight));
}
At this point, our main logic for the GraphWeighted is done. We simply need some method to print edges, check if there's an edge between two nodes and reset all visited nodes.

Let's start off with printing edges:

public void printEdges() {
    for (NodeWeighted node : nodes) {
        LinkedList<EdgeWeighted> edges = node.edges;

        if (edges.isEmpty()) {
            System.out.println("Node " + node.name + " has no edges.");
            continue;
        }
        System.out.print("Node " + node.name + " has edges to: ");

        for (EdgeWeighted edge : edges) {
            System.out.print(edge.destination.name + "(" + edge.weight + ") ");
        }
        System.out.println();
    }
}
Now, a simple check if two nodes have an edge between them:

public boolean hasEdge(NodeWeighted source, NodeWeighted destination) {
    LinkedList<EdgeWeighted> edges = source.edges;
    for (EdgeWeighted edge : edges) {
        // Again relying on the fact that all classes share the
        // exact same NodeWeighted object
        if (edge.destination == destination) {
            return true;
        }
    }
    return false;
}
And finally, the method that resets all visited nodes so we can practically reset the algorithm:

// Necessary call if we want to run the algorithm multiple times
public void resetNodesVisited() {
    for (NodeWeighted node : nodes) {
        node.unvisit();
    }
}
Implementing Dijkstra's Algorithm
With our weighted graph and nodes all done, we can finally focus on Dijkstra's Algorithm itself. It's going to be a bit long with many explanations in the comments, so bear with us for a moment:

public void DijkstraShortestPath(NodeWeighted start, NodeWeighted end) {
    // We keep track of which path gives us the shortest path for each node
    // by keeping track how we arrived at a particular node, we effectively
    // keep a "pointer" to the parent node of each node, and we follow that
    // path to the start
    HashMap<NodeWeighted, NodeWeighted> changedAt = new HashMap<>();
    changedAt.put(start, null);

    // Keeps track of the shortest path we've found so far for every node
    HashMap<NodeWeighted, Double> shortestPathMap = new HashMap<>();

    // Setting every node's shortest path weight to positive infinity to start
    // except the starting node, whose shortest path weight is 0
    for (NodeWeighted node : nodes) {
        if (node == start)
            shortestPathMap.put(start, 0.0);
        else shortestPathMap.put(node, Double.POSITIVE_INFINITY);
    }

    // Now we go through all the nodes we can go to from the starting node
    // (this keeps the loop a bit simpler)
    for (EdgeWeighted edge : start.edges) {
        shortestPathMap.put(edge.destination, edge.weight);
        changedAt.put(edge.destination, start);
    }

    start.visit();

    // This loop runs as long as there is an unvisited node that we can
    // reach from any of the nodes we could till then
    while (true) {
        NodeWeighted currentNode = closestReachableUnvisited(shortestPathMap);
        // If we haven't reached the end node yet, and there isn't another
        // reachable node the path between start and end doesn't exist
        // (they aren't connected)
        if (currentNode == null) {
            System.out.println("There isn't a path between " + start.name + " and " + end.name);
            return;
        }

        // If the closest non-visited node is our destination, we want to print the path
        if (currentNode == end) {
            System.out.println("The path with the smallest weight between "
                                   + start.name + " and " + end.name + " is:");

            NodeWeighted child = end;

            // It makes no sense to use StringBuilder, since
            // repeatedly adding to the beginning of the string
            // defeats the purpose of using StringBuilder
            String path = end.name;
            while (true) {
                NodeWeighted parent = changedAt.get(child);
                if (parent == null) {
                    break;
                }

                // Since our changedAt map keeps track of child -> parent relations
                // in order to print the path we need to add the parent before the child and
                // it's descendants
                path = parent.name + " " + path;
                child = parent;
            }
            System.out.println(path);
            System.out.println("The path costs: " + shortestPathMap.get(end));
            return;
        }
        currentNode.visit();

        // Now we go through all the unvisited nodes our current node has an edge to
        // and check whether its shortest path value is better when going through our
        // current node than whatever we had before
        for (EdgeWeighted edge : currentNode.edges) {
            if (edge.destination.isVisited())
                continue;

            if (shortestPathMap.get(currentNode)
               + edge.weight
               < shortestPathMap.get(edge.destination)) {
                shortestPathMap.put(edge.destination,
                                   shortestPathMap.get(currentNode) + edge.weight);
                changedAt.put(edge.destination, currentNode);
            }
        }
    }
}
And finally, let's define the closestReachableUnvisited() method that evaluates which is the closest node that we can reach and haven't visited before:

private NodeWeighted closestReachableUnvisited(HashMap<NodeWeighted, Double> shortestPathMap) {

    double shortestDistance = Double.POSITIVE_INFINITY;
    NodeWeighted closestReachableNode = null;
    for (NodeWeighted node : nodes) {
        if (node.isVisited())
            continue;

        double currentDistance = shortestPathMap.get(node);
        if (currentDistance == Double.POSITIVE_INFINITY)
            continue;

        if (currentDistance < shortestDistance) {
            shortestDistance = currentDistance;
            closestReachableNode = node;
        }
    }
    return closestReachableNode;
}
Now that we have all that - let's test our algorithm on the first example from above:

public class GraphShow {
    public static void main(String[] args) {
        GraphWeighted graphWeighted = new GraphWeighted(true);
        NodeWeighted zero = new NodeWeighted(0, "0");
        NodeWeighted one = new NodeWeighted(1, "1");
        NodeWeighted two = new NodeWeighted(2, "2");
        NodeWeighted three = new NodeWeighted(3, "3");
        NodeWeighted four = new NodeWeighted(4, "4");
        NodeWeighted five = new NodeWeighted(5, "5");
        NodeWeighted six = new NodeWeighted(6, "6");

        // Our addEdge method automatically adds Nodes as well.
        // The addNode method is only there for unconnected Nodes,
        // if we wish to add any
        graphWeighted.addEdge(zero, one, 8);
        graphWeighted.addEdge(zero, two, 11);
        graphWeighted.addEdge(one, three, 3);
        graphWeighted.addEdge(one, four, 8);
        graphWeighted.addEdge(one, two, 7);
        graphWeighted.addEdge(two, four, 9);
        graphWeighted.addEdge(three, four, 5);
        graphWeighted.addEdge(three, five, 2);
        graphWeighted.addEdge(four, six, 6);
        graphWeighted.addEdge(five, four, 1);
        graphWeighted.addEdge(five, six, 8);

        graphWeighted.DijkstraShortestPath(zero, six);
    }
}
We get the following output:

The path with the smallest weight between 0 and 6 is:
0 1 3 5 4 6
The path costs: 20.0
Which is exactly what we got by manually doing the algorithm.

Using it on the second example from above gives us the following output:

The path with the smallest weight between 8 and 6 is:
8 1 4 7 6
The path costs: 12.0
Furthermore, while searching for the cheapest path between two nodes using Dijkstra, we most likely found multiple other cheapest paths between our starting node and other nodes in the graph. Actually - we've found the cheapest path from source to node for every visited node. Just sit on that for a moment, we'll prove this in a latter section.

However, if we wanted to know the shortest path between our starting node and all other nodes we would need to keep running the algorithm on all nodes that aren't visited yet. In the worst case scenario we'd need to run the algorithm numberOfNodes - 1 times.

Note: Dijkstra's algorithm is an example of a greedy algorithm. Meaning that at every step, the algorithm does what seems best at that step, and doesn't visit a node more than once. Such a step is locally optimal but not necessarily optimal in the end.

This is why Dijkstra fails with negatively weighted edges, it doesn't revisit nodes that might have a cheaper path through a negatively weighted edge because the node has already been visited. However - without negatively weighted edges, Dijkstra is globally optimal (i.e. it works).

